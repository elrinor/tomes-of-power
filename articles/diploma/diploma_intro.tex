\begin{titlepage}
    \begin{center}
	{\small \sc Московский государственный университет имени М.~В.~Ломоносова\\
	Факультет вычислительной математики и кибернетики\\
	Кафедра системного программирования\\}
	\vfill
	{\LARGE Дипломная работа на тему}\\
	{\Large <<восстановление объектных структур данных при декомпиляции>>}
    \end{center}
    \begin{flushright}
	\vfill {Выполнил:\\
	студент 527 группы\\
	Фокин~А.~П.\\
	~\\
	Научный~руководитель:\\
%	к.ф.-м.н.,~доцент~Гайсарян~С.~С.
    к.ф.-м.н.,~доцент~Чернов~А.~В.
    }
    \end{flushright}
    \begin{center}
	\vfill
	{\small Москва, 2009}
    \end{center}
\end{titlepage}

\newpage
\begin{abstract}
В работе рассматриваются методы автоматического восстановления объектных структур данных из низкоуровневого представления программ на языке Си++.
\end{abstract}

\newpage
\tableofcontents

\newpage
\listoffigures

\newpage
\section*{Введение}
\addcontentsline{toc}{section}{Введение}
Программное обеспечение требует постоянных изменений --- для исправления ошибок, добавления новой функциональности, адаптации к новым требованиям, или новым возможностям аппаратуры. При этом исходный код программы является ключом к ее пониманию, и если он недоступен, то понимание принципов ее работы и внесение изменений оказывается чрезвычайно затруднено. Так как не редки случаи отсутствия исходного кода используемого приложения или компонента, то актуальной становится задача \textit{обратного проектирования}\footnote{Здесь и далее определения всех терминов, выделенных {\it курсивом}, даны в приложении А.}. В применении к программному обеспечению целью обратного проектирования является повышение уровня абстракции представления программ. В процессе повышения уровня абстракции принято выделять несколько этапов \cite{emmerik07}:

\begin{enumerate}
\item Получение ассемблерного представления программы из бинарного модуля, называемое дизассемблированием.
\item Восстановление программы на языке высокого уровня из ассемблерного представления, называемое декомпиляцией.
\item Последующее применение средств повышения уровня абстракции программ на языке высокого уровня в зависимости от целей анализа.
\end{enumerate}

В настоящее время для разработки большого числа программных систем применяется объектно-ориентированный подход с использованием языка Си++, и потому весьма актуальны соответствующие задачи обратного проектирования. Дизассемблирование написанных на языке Си++ программ не имеет каких-либо специфичных особенностей, и потому может быть произведено стандартными методами. В настоящее время в основном рассматриваются задачи декомпиляции в язык Си, однако язык Си++ привносит новые концепции, не имеющие прямого отражения в Си --- в частности, концепции объектно-ориентированного проектирования, такие как наследование и полиморфизм. Поэтому при декомпиляции кода, изначально написанного на языке Си++, необходимо как можно более полно восстанавливать эти концепции.

%Декомпиляция же для языка Си++ является задачей, представляющей определенные трудности, так как Си++ оперирует множеством абстракций, некоторые из которых оказываются никак не отражены в машинном коде, получаемом в результате компиляции. Основными концепциями объектно-ориентированного подхода является классы и объекты, и потому восстановление объектных структур существенно упрощает понимание принципов работы подобных программ.



\newpage
\section{Постановка задачи}\label{chapter:problem}
Цель данной работы --- разработка и реализация методов восстановления объектных структур данных из низкоуровневого представления программ, написанных на языке Си++, для компиляторов GCC\footnote{GNU Compiler Collection --- набор компиляторов для различных языков программирования и платформ, разработанный в рамках проекта GNU и распространяемый на условиях GNU General Public License.} и MSVC\footnote{Microsoft Visual C++ --- интегрированная среда разработки приложений на языке Си++, разработанная фирмой Microsoft и поставляемая как часть комплекта Microsoft Visual Studio.} для платформы x86. При этом предполагается, что программа на языке Си++ не была подвергнута обфускации, и рассматриваемое низкоуровневое представление было получено с использованием одного из перечисленных компиляторов без произведения каких-либо последующих преобразований. Под низкоуровневым представлением понимается программа на языке ассемблера, полученная дизассемблированием исполняемого файла. В дальнейшем будем называть низкоуровневое представление ассемблерным.

Необходимо восстановить иерархию использованных в программе {\it полиморфных классов}. Дадим определение корректно восстановленной иерархии полиморфных классов. Пусть $N$ --- это некоторый компилятор с языка Си++ в ассемблер, а $N_n$ --- компилятор $N$ с набором опций $n$. Тогда для некоторой программы $\bP$ на языке Си++, $\bA = N_n(\bP)$ является программой на языке ассемблера, полученной путем компиляции программы $\bP$ компилятором $N$ с набором опций $n$. Будем говорить, что множество полиморфных классов $\gCa$ с определенным на нем бинарным отношением непосредственного наследования $\leftarrow \; \subseteq \gCa \times \gCa$ является результатом корректного восстановления иерархии полиморфных классов ассемблерной программы $\bA$, если существует $\bP'$ --- программа на языке Си++, такая, что для множества ее полиморфных классов $\gCpd$ выполнено $\gCpd = \gCa$, для отношения непосредственного наследования $\leftarrow_{\bP'}$ на множестве $\gCpd$ выполнено $\leftarrow_{\bP'} \; = \; \leftarrow$, и существует компилятор $N'$ с набором опций $n'$ такой, что ассемблерные программы $\bA' = N'_{n'}(\bP')$ и $\bA$ эквивалентны в некотором смысле.

Результатом работы разрабатываемых методов должна быть корректно восстановленная иерархия полиморфных классов для входной ассемблерной программы $\bA$, а также соответствие между восстановленными классами и принадлежащими им виртуальными функциями.




\newpage
\section{Обзор существующих решений}
В общей задаче декомпиляции до сих пор существует много нерешенных проблем. Несмотря на то, что проблема декомпиляции известна давно, было проведено лишь небольшое количество исследований в области восстановления объектных структур данных для языка Си++. Для таких языков, как C\#, восстановление объектных структур зачастую не представляет сложностей, и существует множество успешных декомпиляторов для этого языка, способных восстановить код в практически изначальном виде \cite{wiener05}.

Наиболее близки к проблеме восстановления объектных структур данных исследования в области восстановления типов данных при декомпиляции, например \cite{mycroft99}. Однако такие исследования фокусируются на восстановлении внутренней структуры типов данных, а не отношений между ними.

Интересны с точки зрения рассматриваемой проблемы работы \cite{emmerik04} и \cite{emmerik07}. Первая из этих работ посвящена обзору основных проблем, возникших при использовании декомпилятора Boomerang \cite{boomerang} для восстановления алгоритмов, использованных в системе анализа речи. Система представляла собой большое приложение для операционной системы Windows, написанное на языках Си и Си++, и авторам были доступны исходные коды прототипа системы. В этой работе авторы описали возникшие при декомпиляции проблемы и использованные для их решения методы, а также некоторые <<неожиданности>>, обнаруженные в ходе работы. Одной из таких <<неожиданностей>> стало наличие в исполнимом модуле {\it информации о типах времени выполнения}, с использованием которой авторам удалось восстановить полную иерархию полиморфных классов системы со всеми именами. Однако технические детали восстановления иерархии классов авторами предоставлены не были. Во второй работе также упоминается возможность использования информации о типах времени выполнения при декомпиляции, но детали не приводятся.

С точки зрения восстановления объектных структур данных наиболее интересна работа \cite{sabanal07}. Авторы этой работы являются специалистами в области анализа вредоносных программ, и имеют большой опыт изучения принципов работы программ при отсутствии исходного кода. В данной работе авторами описаны приемы, с использованием которых возможно восстановление иерархий полиморфных классов как в случае присутствия информации о типах времени выполнения в исполнимом файле, так и в случае ее отсутствия.

Для случая присутствия информации о типах времени выполнения в работе представлен метод извлечения этой информации из исполнимого файла и ее анализа. Также приведены все используемые для хранения этой информации компилятором MSVC структуры. Для случая отсутствия информации о типах времени выполнения авторами предложен метод восстановления отношений между классами, основанный на анализе конструкторов, деструкторов, и таблиц виртуальных функций. Описанные алгоритмы анализа конструкторов, деструкторов, и виртуальных функций, были реализованы авторами данной работы, и протестированы на коде реально существующих вредоносных программ. Также авторами были предложены способы восстановления полей классов и распознавания методов, не являющихся виртуальными.

Основная проблема методов, предложенных в работе \cite{sabanal07} --- это их неточность. Во многих случаях предложенные методы работают, но существует также множество примеров, на которых они не полностью восстанавливают требуемую информацию об объектных структурах данных, требуя дополнительного ручного анализа, или восстанавливают ее не точно.

Как видно, задаче восстановления объектных структур данных для ассемблерного представления программ, написанных на языке Си++, на данный момент было уделено мало внимания, и было проведено лишь небольшое количество исследований в этой области. Несмотря на то, что в рассмотренных работах было представлено несколько методов анализа объектных структур данных, эти методы опираются либо на использования информации о типах времени выполнения, которая может отсутствовать, либо на соображения, которые в общем случае не выполняются, и потому могут привести к неверным результатам.



























