# Дизайн API в С++

В этом году на C++ Russia я рассказывал про [API дизайн](https://cppconf.ru/en/talks/97d7a921faf846189a24169a4659b61f). Эта статья – пересказ и переосмысление моего доклада.

То, что я здесь расскажу, основано на моем личном опыте – про API дизайн я думаю уже лет 15, с того момента как в 2008м начал читать ревью библиотек на входе в boost (кстати, всем рекомендую).

В первой части я сфокусируюсь на базовых вещах, которые применимы практически к любому императивному языку программирования, не только к C++. Будет также часть 2, более приближенная собственно к C++, в которой я расскажу о некоторых фичах языка и стандартной библиотеки, которые помогут вам сделать ваши API еще лучше.


# Программная Архитектура

Сначала поговорим об архитектуре. В современных инженерных кругах каждый раз когда кто-то говорит слово "Архитектура," многие сразу думают о System Design собеседованиях в крупные зарубежные компании – как из кафки, редиса и PostgreSQL собрать сервис, который будет json'ы перекладывать.

Мы сегодня будем говорить об архитектуре на более низком уровне – об архитектуре на уровне отдельной программы или сервиса. 

У вас было такое, что вы реализуете какую-то функциональность, код получается сложный и непонятный, вы сажаете баги, в итоге после долгих мучений ваш код все-таки начинает работать, и вы со вздохом облегчения коммитите свои изменения. И все это время вас не покидает ощущение, что все то, что вы делаете, можно сделать проще, но для этой легкости и простоты вам чего-то не хватает, и вы не понимаете, чего.

А потом приходит ваш друг-продакт и говорит, что требования изменились, и вы с ужасом понимаете, что переделывать написанный код займет примерно столько же времени, сколько написать новый.

Если вы оказались в такой ситуации – вам пора задуматься об архитектуре вашего ПО.

Архитектура – это вид с высоты птичьего полета. Например, если вы пишете графический редактор, то вам наверняка придется написать код сохранения и загрузки разных форматов изображений, код инструментов, которые будут доступны пользователю, реализацую undo/redo, код различных фильтров, и т.п. Архитектура – это про то, как весь этот код связать в единое целое так, чтобы получилось достаточно гибкое решение.

Чем архитектура, о которой вовремя подумали, отличается от архитектуры, которая сама как-то зародилась, как жизнь в кастрюле с макаронами которую вы забыли на балконе? Что вообще такое "хорошая архитектура?" Мне нравится тейк автора Game Programming Patterns:

> What is good software architecture?
> For me, good design means that when I make a change, it’s as if the entire program was crafted in anticipation of it. I can solve a task with just a few choice function calls that slot in perfectly, leaving not the slightest ripple on the placid surface of the code.
> 
> That sounds pretty, but it’s not exactly actionable. “Just write your code so that changes don’t disturb its placid surface.” Right.
> 
> Let me break that down a bit. The first key piece is that architecture is about change. Someone has to be modifying the codebase. If no one is touching the code — whether because it’s perfect and complete or so wretched no one will sully their text editor with it — its design is irrelevant. The measure of a design is how easily it accommodates changes. With no changes, it’s a runner who never leaves the starting line.

За мыслью о легкости изменений на самом деле лежит довольно много:
* Хорошая архитектура помогает быстро разобраться в коде. Это в частности предполагает минимизацию количества абстракций и движущихся частей, о которых надо помнить при написании нового кода или модификации существующего.
* Хорошая архитектура помогает с локальностью изменений. У вас бывало такое, что чтобы реализовать какую-то новую фичу нужно воткнуть десяток-другой if'ов по всей кодовой базе? Это пример нелокальности изменений.
* Хорошая архитектура помогает не сажать баги. 
* Если вы все-таки посадили баг, то хорошая архитектура помогает быстро его найти.
* Хорошая архитектура находит баланс между гибкостью и простотой. Вы наверняка участвовали в проектах, в которых разработчики увлеклись и *наархитектурили* – такое бывает когда продуктовые требования не ясны, и инженеры стараются предусмотреть все возможные пути дальнейшего развития продукта, и в итоге за *архитектурностью* теряется суть происходящего. 
* Хорошая архитектура помогает быстрее решать возникающие бизнес-задачи. Реализовывать фичи. Ускорять тормозные участки.

И самое главное – хорошая архитектура отвечает внешним требованиям. Это в частности означает, что если вы пишете прототип, то ничего из того что я здесь написал вам не нужно – вам нужно за минимальное время собрать что-то рабочее. Возможно после этого вы этот прототип просто выкинете.

Об архитектуре нужно задумываться если:
* Вы пишете код, который будет долго жить и широко использоваться.
* Вы пишете библиотечный код.
* Вы любите неконтролируемо *архитектурить* и хотите научиться делать это контролируемо.


Что вообще такое API Design?
----------------------------

Понятие API дизайна на самом деле тесно переплетено с понятием программной архитектуры.

И если архитектура в целом – это вид с высоты птичьего полета, то API дизайн – это вид вблизи, это то, что происходит между отдельными компонентами системы. Как связать А и Б, как написать код так чтобы потом не ловить баги, и тп.

Про архитектуру вы думаете когда проектируете ваше ПО, и когда делаете достаточно глобальные рефакторинги. Про API вы думаете каждый день. Каждый раз когда вы пишете сигнатуру новой функции – вы занимаетесь API дизайном. Вот так – если программируешь – значит ты API-дизайнер!

Все свойства хорошей архитектуры напрямую транслируются в API дизайн.


Зачем вообще нужны хорошие API?
-------------------------------

Вот две интересные ссылки:
* [The Wonderfully Terrible World of C and C++ Encoding APIs (with Some Rust)](https://thephd.dev/the-c-c++-rust-string-text-encoding-api-landscape). 
* И продолжение – [cuneicode, and the Future of Text in C](https://thephd.dev/cuneicode-and-the-future-of-text-in-c).

По этим ссылкам один участник комитета по стандартизации C и С++ очень качественно *горит*. У многих людей на словосочетание "комитет по стандартизации С++" аллергия – они сразу представляют себе сборище бородатых дедов, которые все время что-то там стандартизируют, и каждый раз получается какая-то ~~какаха~~ оторванная от жизни фигня (`std::chrono`, например). Так вот, автор статьи – сразу в друх лагерях, и честно решил конструктивно посмотреть на свои страдания – "если комитет делает фигню, то я сам стану членом комитета и научу их как надо!" В частности, он недавно (протащил)[https://open-std.org/JTC1/SC22/WG14/www/docs/n3017.htm] `#embed` в С.

И горит он качественно потому, что на дворе 2023й год, нормальной библиотеки для работы с разными энкодингами по-прежнему нет, и мы все еще иногда наблюдаем что-то такое:
# invalid_encoding.png

На самом деле проблема на скриншоте глубже и многограннее, чем банальное отсутствие библиотеки для работы с разными энкодингами, но в корне проблемы все равно лежат кривые API.

Как и в корне многих других проблем в [национальной базе уязвимостей](https://nvd.nist.gov/). Зачастую все начинается с примерно такого кода:
```cpp
char buf[1024];
```

И заканчивается вот таким кодом:
```cpp
// Checking string size is for retards!
strcpy(buf, totally_safe_string);
```

`strcpy` – это типичный пример сломанного API, который уже не починить, можно только выкинуть. Функции больше 40 лет, ей продолжают пользоваться, и она [продолжает стрелять](https://cve.mitre.org/cgi-bin/cvekey.cgi?keyword=strcpy).

<!---
Функции 40 лет:
https://stackoverflow.com/questions/25300040/is-it-possible-to-find-out-when-the-current-syntax-of-strcpy-was-added-to-the-c
-->

Но я уже слышу ваши возражения. API в недрах стандартной библиотеки? Кривой `strcpy`? Я json'ы перекладываю, и вообще не помню когда в последний раз писал вызов `strcpy` руками, какое отношение это все имеет лично ко мне?

Очень простое. У вас есть такие же коллеги, которые точно также пользуются вашим кодом, как мы все пользуемся стардартной библиотекой. Они точно так же горят, когда пытаются переиспользовать что-то, что вы написали не задумываясь о том, как сделать ваш API удобным. Пострадав немного, они решают сделать то же самое, но у себя и лучше. "Нет, мы не велосипедим," – говорят они, когда вы узнаете об этом и начинаете задавать недобные вопросы, – "просто существующее решение нам не подходит." Они конечно же тоже не думают об API дизайне, и спустя несколько лет в вашей компании уже 5 копий одной и той же функциональности, которые растеклись в разные стороны по пространству решений вашей задачи. Тимлиды справедливо замечают, что чтобы это поддерживать, нужно больше программистов – и у вас появляются новые коллеги, которые тоже не думают про API дизайн. "Эх, вот если бы можно было все выкинуть и переписать заново," – вздыхаете вы за пивом в баре с коллегами спустя еще несколько лет.

Так вот, у меня хорошие новости – не нужно все переписывать.

# Правило API дизайна #1
## Проектируйте API так, чтобы его нельзя было использовать неправильно

Идея этого правила очень простая – ваш код должен или работать корректно, или завершаться с ошибкой (или `assert`'ом), и не должно существовать последовательности вызовов, которые приводят ваш класс (или модуль) в некорректное состояние.

Более того, чем меньше у вашего API способов завершиться с ошибкой – тем лучше! Зачем думать об ошибках и обрабатывать их, если можно спроектировать API, в котором их просто не будет?

Давайте посмотрим на несколько примеров.


### Пример #1: логгирование

Например, предположим что вы пишете обертку над библиотекой для логгирования:
```cpp
class Logger {
public:
	/**
	 * @param category		Log category name. Category must have a log level assigned (`setCategoryLogLevel` must be called first).
	 * @param level   		Message log level.
	 * @param fmt, args     Log message.
	 */
	template<class... Args>
	void log(std::string_view category, LogLevel level, fmt::format_string<Args...> fmt, Args&&... args);

	/**
	 * @param category      Log category name.
	 * @param level         New log level for this category. Log messages with lower log level will be ignored.
	 */
	void setCategoryLogLevel(std::string_view category, LogLevel level);
}
```

Вы хотите ловить опечатки в названиях категорий, и поэтому в методе `log` вы проверяете, что категория уже зарегистрирована – вы знаете, что у ваших коллег толстые пальцы, и опечатываться они точно будут. Но можно то же самое сделать лучше:

```cpp
class LogCategory {
public:
	LogCategory(std::string_view name, LogLevel level);

	void setLogLevel(LogLevel level);

	// ...
};

class Logger {
public:
	template<class... Args>
	void log(const LogCategory &category, LogLevel level, fmt::format_string<Args...> fmt, Args&&... args);
}
```

При таком API у вас сразу пропадает проблема того, что пользователь может опечататься в названии категории – опечатываться-то теперь негде! Только в назывании переменной типа `LogCategory`, а это поймает компилятор.


# Пример #2: Менеджер CSV файлов

Рассмотрим еще один пример. Предположим, что вы пишете какую-то автоматизацию для машинного обучения, и вам не повезло и все данные хранятся на диске в CSV файлах. Логика приложения такая, что по CSV файлам считаются статистики, которые потом используются в коде – например, для принятия решения об обновлении файла. Вы решаете написать обертку:

```cpp
struct CsvStats {
    DateTime startTime; // First timestamp in CSV table.
    DateTime endTime;   // Last timestamp in CSV table.
    // ...
};

class CsvDb {
public:
    explicit CsvDb(std::string_view path);

    std::string path(std::string_view tableName);

    CsvStats stats(std::string_view tableName);
    void setStats(std::string_view tableName, CsvStats stats);
};
```

В целом очень простой интерфейс – есть возможность получить полный путь до таблицы по имени, и есть getter и setter для статистик. Статистики сохраняются на диске в каком-нибудь `db.ini` и flush'атся после каждого вызова `setStats`. Ожидается, что пользоваться вашей оберткой будут примерно следующим образом:
1. Получат статистику по имени таблицы.
2. Если в таблице не хватает данных – докачают их.
3. Получат путь до файла с таблицей вызвав `path`, подмержат туда скачанные данные.
4. Вызовут `setStats`, чтобы обновить статистики на новые.
5. Используют обновленную таблицу.

Что здесь может пойти не так? Например то, что подсчет статистик – целиком на пользователе, и что подмерживание таблицы и обновление статистик – это не атомарная операция.

Как можно сделать то же самое лучше:

```cpp
struct CsvStats {
    DateTime startTime;
    DateTime endTime;
    // ...
};

class CsvDb {
public:
    explicit CsvDb(std::filesystem::path path);

    CsvTableReader open(std::string_view tableName);
    CsvTableWriter replace(std::string_view tableName);

    CsvStats stats(std::string_view tableName);
};

// Skipping CsvTableReader & CsvTableWriter for brevity.
```

Что изменилось:
* Теперь пользователь нашего интерфейса вообще ничего не знает о файлах.
* Статистики насчитываются и сохраняются внутри `CsvTableWriter`. Пользователю не нужно делать это самому.
* Интерфейс стал лучше отражать суть происходящего – `open` и `replace` это по сути getter и setter для отдельной таблицы, и setter теперь можно реализовать так, чтобы таблица и ее статистика обновлялись атомарно. Предыдущая версия API концентрировалась на getter'ах и setter'ах для статистик

Правда, теперь у нас 4 класса вместо двух. Это должно навести вас на мысль!


# Правило API дизайна #2
## Divide & Conquer

Вы наверняка знакомы с акронимом SOLID. Я, честно признаться, никогда не мог запомнить, что означают все эти буквы, но две из них я помню очень четко. Даже если вы разбудите меня посреди ночи, то я уверенно вам скажу, что S – это про single responsibility, а L – это про Liskov substitution.

За S в SOLID на самом деле сидит довольно глубокая мысль. В оригинале правило звучит как "there should never be more than one reason for a class to change" и на деле это означает, что зоны ответственности классов должны быть очень небольшими. А значит и сами классы тоже должны быть небольшими.

Почему небольшие классы это хорошо? Давайте подумаем о том, как вы на самом деле пишете код:
1. Сначала вам нужно осознать задачу – какую функциональность вы вообще хотите реализовать.
2. Затем вам нужно осознать контекст – буквально, загрузить в голову весь код, который вам нужно будет менять, и от которого так или иначе будет зависеть новая функциональность.
3. После этого вам нужно придумать решение – *как* вы поменяете код, который уже у вас в голове. 
4. Постучать пальцами по клавиатуре.

Зачастую, вся сложность оказывается вовсе не в шаге 4. Если вы работаете с большими классами, то они не влезают в вашу оперативную память. И вы или страдаете и тратите больше времени, чем могли бы, или сажаете баги.

Более того, внутри класса нет границ, все поля доступны их любого метода, и количество возможных взаимодействий между частями класса растет **как квадрат** от размера класса. А вместе с количеством взаимодействий растет и количество багов.

Дробя классы на кусочки, вы расставляете границы там, где они логически должны быть, вы уменьшаете количество возможных взаимодействий, и делаете жизнь ваших пользователей проще – небольшие классы легче читать и осознавать.

Аналогично работает и с библиотеками. Классы в "помойке классов" начинают зависеть друг от друга, снова квадрат зависимостей и баги. Дробите на более мелкие библиотеки! И такая же логика применима к фукциям – не просто так все ругают функции на 10 экранов.


### Пример #3: парсинг строковых данных

Это реальный код который я взял из одного из своих проектов. Предположим, что у вас null-терминированные строки лежат в бинарном виде в файле, и вам нужно поднять их в память. И у вас уже есть вот такой код:

```cpp
/**
 * @param buffer 			Input buffer to parse, contains null-terminated strings.
 * @param[out] result		Parsed strings.
 */
void parseStrings(const Buffer &buffer, std::vector<std::string> *result) {
    size_t pos = 0;                                                        
    while (pos < buffer.size()) {
    	// Extract the next string.
        const char *nextPos = static_cast<const char *>(memchr(buffer.data() + pos, '\0', buffer.size() - pos));
        size_t size = (nextPos ? nextPos - buffer.data() : buffer.size()) - pos;
        std::string str = std::string(buffer.data() + pos, size);

        // Remove quotes if the string is quoted.
        if (str.size() >= 2 && str.front() == '"' && str.back() == '"')
            str = str.substr(1, str.size() - 2);

        // Store result & advance.
        result->push_back(std::move(str));
        pos += size + 1;
    }
}
```

Вы подобный код наверняка видели много раз. Что с ним не так? Например то, что неподготовленному человеку вообще не ясно, что происходит в первых трех строках. Просто попробуйте вчитаться – вот например, вы вообще помните, что возвращает `memchr`?

Тот же код можно гораздо более понятно, выделив несколько абстракций:

```cpp
void parseStrings(const Buffer &buffer, std::vector<std::string> *result) {
    MemoryInput input(buffer);

    std::string line;
    while (input.readLine(&line, '\0'))
        result->push_back(unquote(line));
}
```

Новая фукнция делает то же самое, что и старая, но в отличие от старой код теперь написан так, что всем сразу ясно, что в этой функции происходит. Мы добились этого за счет введения двух новых сущностей:
1. Класса `MemoryInput`, который отвечает за потоковое чтение из участка памяти.
2. Функции `unquote`, короая удаляет кавычки.

И класс, и новую фукнцию теперь можно покрыть тестами и переиспользовать в других местах.

На проделанный рефакторинг можно смотреть как на разделение нашего решения на *слои абстракции*. Для удобного потокового чтения из памяти нам не хватало соответствующей абстракции – мы выделили ее в отдельный класс с четко обозначенным интерфейсом, и теперь взаимодействуем с памятью только через этот интерфейс. И этот интерфейс делит наш код на *слои* – код ниже по стеку работает с сырой памятью, а код выше – с более высокоуровневым интерфейсом.

В целом, это очень хороший подход к дизайну API. Если вы видите сложный код:
1. Подумайте, каких абстракций вам не хватает.
2. Выделите их в отдельные сущности, и разделите свой код на слои с их использованием.

> 📝 Если пойти чуть дальше, то становится ясно, что этого кода вообще быть не должно. Если у вас null-терминированные строки лежат в файле, то просто замапьте его в память и сделайте массив из `std::string_view`, которые в эту память смотрят. А еще лучше – если у вас не сотни тысяч строк, то сложите их просто в какой-нибудь human-readable формат, для которого умные люди уже написали парсинг. Json, toml, ini, yaml, prototext, и т.п.


### Пример #4: QFuture

Давайте теперь посмотрим на жизненный пример из библиотеки Qt – класс `QFuture`. Это по сути прокачанный аналог `std::future`, абстракция над асинхронным вычислением. Интерфейс выглядит примерно так:

```cpp {all}
template<class T>
class QFuture {
public:
    QFuture(const QFuture &other);

    const_iterator begin() const;
    const_iterator end() const;
    QList<T> results() const;

    void cancel();
    T takeResult();
    T result() const;

    auto then(Function &&function);
    auto then(QThreadPool *pool, Function &&function);
    auto then(QObject *context, Function &&function);

    bool isCanceled() const;
    bool isFinished() const;
    bool isRunning() const;
    bool isStarted() const;
    bool isValid() const;

    // ...
};
```

Какие у этого интерфейса есть проблемы:
* `QFuture` это ref-counted класс, то есть по сути `QFuture` это аналог `std::shared_future`.
* С другой стороны у `QFuture` есть метод `takeResult`, который явно не вписывается в концепцию `std::shared_future`.
* А `begin` / `end` – это вообще история про канал / асинхронную последовательность.
* Метод `then` с одним аргументом фундаментально сломан – у вас нет способа гарантировать, что переданная функция не будет вызвана напрямую изнутри метода.
* Метод `then` принимающий `QObject *` в качестве контекста работает не так, как опытный пользователь Qt может ожидать – в отличие от `QObject::connect`, `QFuture::then` не следит за живостью переданного объекта.
* Огромная куча методов `isXYZ` дают доступ к текущему состоянию объекта, но даже из документации не ясно, какие состояния являются взаимоисключающими, а какие – нет. Если состояния являются взаимоисключающими, то лучше предоставлять единый метод `state()`.

В общем, `QFuture` пытается быть всем и сразу. У этого желания есть большой минус, и вы увидите его если попробуете почитать исходники – в `QFutureInterfaceBasePrivate` целых 20 полей, и уследить за происходящим там очень сложно.

При этом, если вы, прочитав исходники, попробуете придумать имя для этого класса, которое хорошо бы отражало его функциональность, то у вас не получится. И это должно заставить вас задуматься.


# Правило #3
## Тратьте время на придумывание хороших имен!

Как известно, в Computer Science есть только две сложные проблемы – инвалидация кешей и придумывание имен. В этой шутке есть большая доля правды – если у вас что-то не получается нормально назвать, то это зачастую означает, что вы хотите странного, и вам нужно переделывать свой дизайн.

Перед именованием потратьте время и сформулируйте, в чем вообще концептуальная суть абстракции, которую вам нужно назвать. Не поддавайтесь на соблазны – никто не будет рад очередному классу, заканчивающемуся на `Helper`. Если все равно не получается – воспользуйтесь [thesaurus.com](https://www.thesaurus.com/) или [ChatGPT](http://chat.openai.com/). Если и после этого получается фигня – значит вы придумали кривую абстракцию, думайте еще.


### Продолжаем пример #4: QFuture

В случае `QFuture` из примера выше, если вы зададите себе правильные вопросы, то будет понятно, что за `QFuture` спрятались сразу несколько абстракций, которые стоит разделить:

```cpp
template<class T>
class QAsyncSequence {
public:
    void cancel();
    const_iterator begin() const;
    const_iterator end() const;
    QList<T> results() const;
    // ...
}

template<class T>
class QSharedFuture {
public:
    QSharedFuture(const QSharedFuture &other); 
    void cancel();
    T result() const;
    // ...
}

template<class T>
class QUniqueFuture {
public:
    QUniqueFuture(QUniqueFuture &&other); 
    void cancel();
    T takeResult();
    // ...
}
```

`QAsyncSequence` – это абстракция над асинхронной последовательностью, а `QSharedFuture` и `QUniqueFuture` – аналоги `std::shared_future` и `std::future`. У изначального `QFuture` существовали некорректные сценарии использования, которые приводили к ошибки во время выполнения – например, можно было скопировать `QFuture`, для двух копий вызвать `takeResult`, и упасть с `assert`'ом. С новыми интерфейсами такой код просто не получится написать!

Важно обратить внимание на то, как мы пришли к новым интерфейсам – мы думали не о *классах*, а об *абстракциях*. Это очень важная мысль – на самом деле, API дизайн – это прежде работа с абстракциями, и перевод абстракций в конкректные интерфейсы – это последний шаг этой работы.

Но вернемся к `QFuture`. Выше я обратил ваше внимание на то, что метод `QFuture::then` фундаментально сломан – у вас нет способа гарантированно исполнить континуацию в контексте выполнения операции, доступ к результату которой предоставляет `QFuture`. Если операция завершится до вызова `then`, то континуация будет вызвана прямо изнутри вызова `then`, и это никак нельзя обойти.

> 📝 На практике это конечно довольно редкий сценарий – обычно операции внутри `QFuture` толстые, и вы успеваете навесить то что вам нужно через `then` до их завершения. Но сам факт того, что такой простой сценарий по сути сломан, должен навести вас на мысли.

На мой взгляд, `QFuture` и `std::future` – это просто плохие абстракции. Они объединяют в одном интерфейсе асинхронную операцию и контекст, в рамках которого это операция выполняется, и это приводит к проблемам. Можно ли сделать лучше?


### Пример #5: Лучше чем QFuture

Предположим









