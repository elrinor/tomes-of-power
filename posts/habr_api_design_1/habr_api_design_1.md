# Дизайн API в С++

В этом году на C++ Russia я рассказывал про [API дизайн](https://cppconf.ru/en/talks/97d7a921faf846189a24169a4659b61f). Эта статья – пересказ и переосмысление моего доклада.

Будет также часть 2, более приближенная собственно к C++, в которой я расскажу о некоторых фичах языка и стандартной библиотеки, которые помогут вам сделать ваши API еще лучше.


# Программная Архитектура

Сначала поговорим об архитектуре. В современных инженерных кругах каждый раз когда кто-то говорит слово "Архитектура," многие сразу думают о System Design собеседованиях в крупные зарубежные компании – как из кафки, редиса и PostgreSQL собрать сервис, который будет json'ы перекладывать.

Мы сегодня будем говорить об архитектуре на более низком уровне – об архитектуре на уровне отдельной программы или сервиса. 

У вас было такое, что вы реализуете какую-то функциональность, код получается сложный и непонятный, вы сажаете баги, в итоге после долгих мучений ваш код все-таки начинает работать, и вы со вздохом облегчения коммитите свои изменения. И все это время вас не покидает ощущение, что все то, что вы делаете, можно сделать проще, но для этой легкости и простоты вам чего-то не хватает, и вы не понимаете, чего.

А потом приходит ваш друг-продакт и говорит, что требования изменились, и вы с ужасом понимаете, что переделывать написанный код займет примерно столько же времени, сколько написать новый.

Если вы оказались в такой ситуации – вам пора задуматься об архитектуре вашего ПО.

Архитектура – это вид с высоты птичьего полета. Например, если вы пишете графический редактор, то вам наверняка придется написать код сохранения и загрузки разных форматов изображений, код инструментов, которые будут доступны пользователю, реализацую undo/redo, код различных фильтров, и т.п. Архитектура – это про то, как весь этот код связать в единое целое так, чтобы получилось достаточно гибкое решение.

Чем архитектура, о которой вовремя подумали, отличается от архитектуры, которая сама как-то зародилась, как жизнь в кастрюле с макаронами которую вы забыли на балконе? Что вообще такое "хорошая архитектура?" Мне нравится тейк автора Game Programming Patterns:

> What is good software architecture?
> For me, good design means that when I make a change, it’s as if the entire program was crafted in anticipation of it. I can solve a task with just a few choice function calls that slot in perfectly, leaving not the slightest ripple on the placid surface of the code.
> 
> That sounds pretty, but it’s not exactly actionable. “Just write your code so that changes don’t disturb its placid surface.” Right.
> 
> Let me break that down a bit. The first key piece is that architecture is about change. Someone has to be modifying the codebase. If no one is touching the code — whether because it’s perfect and complete or so wretched no one will sully their text editor with it — its design is irrelevant. The measure of a design is how easily it accommodates changes. With no changes, it’s a runner who never leaves the starting line.

За мыслью о легкости изменений на самом деле лежит довольно много:
* Хорошая архитектура помогает быстро разобраться в коде. Это в частности предполагает минимизацию количества абстракций и движущихся частей, о которых надо помнить при написании нового кода или модификации существующего.
* Хорошая архитектура помогает с локальностью изменений. У вас бывало такое, что чтобы реализовать какую-то новую фичу нужно воткнуть десяток-другой if'ов по всей кодовой базе? Это пример нелокальности изменений.
* Хорошая архитектура помогает не сажать баги. 
* Если вы все-таки посадили баг, то хорошая архитектура помогает быстро его найти.
* Хорошая архитектура находит баланс между гибкостью и простотой. Вы наверняка участвовали в проектах, в которых разработчики увлеклись и *наархитектурили* – такое бывает когда продуктовые требования не ясны, и инженеры стараются предусмотреть все возможные пути дальнейшего развития продукта, и в итоге за *архитектурностью* теряется суть происходящего. 
* Хорошая архитектура помогает быстрее решать возникающие бизнес-задачи. Реализовывать фичи. Ускорять тормозные участки.

И самое главное – хорошая архитектура отвечает внешним требованиям. Это в частности означает, что если вы пишете прототип, то ничего из того что я здесь написал вам не нужно – вам нужно за минимальное время собрать что-то рабочее. Возможно после этого вы этот прототип просто выкинете.

Об архитектуре нужно задумываться если:
* Вы пишете код, который будет долго жить и широко использоваться.
* Вы пишете библиотечный код.
* Вы любите неконтролируемо *архитектурить* и хотите научиться делать это контролируемо.


Что вообще такое API Design?
----------------------------

Понятие API дизайна на самом деле тесно переплетено с понятием программной архитектуры.

И если архитектура в целом – это вид с высоты птичьего полета, то API дизайн – это вид вблизи, это то, что происходит между отдельными компонентами системы. Как связать А и Б, как написать код так чтобы потом не ловить баги, и тп.

Про архитектуру вы думаете когда проектируете ваше ПО, и когда делаете достаточно глобальные рефакторинги. Про API вы думаете каждый день. Каждый раз когда вы пишете сигнатуру новой функции – вы занимаетесь API дизайном. Вот так – если программируешь – значит ты API-дизайнер!

Все свойства хорошей архитектуры напрямую транслируются в API дизайн.


Зачем вообще нужны хорошие API?
-------------------------------

Вот две интересные ссылки:
* [The Wonderfully Terrible World of C and C++ Encoding APIs (with Some Rust)](https://thephd.dev/the-c-c++-rust-string-text-encoding-api-landscape). 
* И продолжение – [cuneicode, and the Future of Text in C](https://thephd.dev/cuneicode-and-the-future-of-text-in-c).

По этим ссылкам один участник комитета по стандартизации C и С++ очень качественно *горит*. У многих людей на словосочетание "комитет по стандартизации С++" аллергия – они сразу представляют себе сборище бородатых дедов, которые все время что-то там стандартизируют, и каждый раз получается какая-то ~~какаха~~ оторванная от жизни фигня (`std::chrono`, например). Так вот, автор статьи – сразу в друх лагерях, и честно решил конструктивно посмотреть на свои страдания – "если комитет делает фигню, то я сам стану членом комитета и научу их как надо!" В частности, он недавно (протащил)[https://open-std.org/JTC1/SC22/WG14/www/docs/n3017.htm] `#embed` в С.

И горит он качественно потому, что на дворе 2023й год, нормальной библиотеки для работы с разными энкодингами по-прежнему нет, и мы все еще иногда наблюдаем что-то такое:
# invalid_encoding.png

На самом деле проблема на скриншоте глубже и многограннее, чем банальное отсутствие библиотеки для работы с разными энкодингами, но в корне проблемы все равно лежат кривые API.

Как и в корне многих других проблем в [национальной базе уязвимостей](https://nvd.nist.gov/). Зачастую все начинается с примерно такого кода:
```cpp
char buf[1024];
```

И заканчивается вот таким кодом:
```cpp
// Checking string size is for retards!
strcpy(buf, totally_safe_string);
```

`strcpy` – это типичный пример сломанного API, который уже не починить, можно только выкинуть. Функции больше 40 лет, ей продолжают пользоваться, и она [продолжает стрелять](https://cve.mitre.org/cgi-bin/cvekey.cgi?keyword=strcpy).

<!---
Функции 40 лет:
https://stackoverflow.com/questions/25300040/is-it-possible-to-find-out-when-the-current-syntax-of-strcpy-was-added-to-the-c
-->

Но я уже слышу ваши возражения. API в недрах стандартной библиотеки? Кривой `strcpy`? Я json'ы перекладываю, и вообще не помню когда в последний раз писал вызов `strcpy` руками, какое отношение это все имеет лично ко мне?

Очень простое. У вас есть такие же коллеги, которые точно также пользуются вашим кодом, как мы все пользуемся стардартной библиотекой. Они точно так же горят, когда пытаются переиспользовать что-то, что вы написали не задумываясь о том, как сделать ваш API удобным. Пострадав немного, они решают сделать то же самое, но у себя и лучше. "Нет, мы не велосипедим," – говорят они, когда вы узнаете об этом и начинаете задавать недобные вопросы, – "просто существующее решение нам не подходит." Они конечно же тоже не думают об API дизайне, и спустя несколько лет в вашей компании уже 5 копий одной и той же функциональности, которые растеклись в разные стороны по пространству решений вашей задачи. Тимлиды справедливо замечают, что чтобы это поддерживать, нужно больше программистов – и у вас появляются новые коллеги, которые тоже не думают про API дизайн. "Эх, вот если бы можно было все выкинуть и переписать заново," – вздыхаете вы за пивом в баре с коллегами спустя еще несколько лет.

Так вот, у меня хорошие новости – не нужно все переписывать.

# Правило API дизайна #1
## Проектируйте API так, чтобы его нельзя было использовать неправильно

Идея этого правила очень простая – ваш код должен или работать корректно, или завершаться с ошибкой (или `assert`'ом), и не должно существовать последовательности вызовов, которые приводят ваш класс (или модуль) в некорректное состояние.

Более того, чем меньше у вашего API способов завершиться с ошибкой – тем лучше! Зачем думать об ошибках и обрабатывать их, если можно спроектировать API, в котором их просто не будет?

Давайте посмотрим на несколько примеров.


### Пример #1: логгирование

Например, предположим что вы пишете обертку над библиотекой для логгирования:
```cpp
class Logger {
public:
	/**
	 * @param category		Log category name. Category must have a log level assigned (`setCategoryLogLevel` must be called first).
	 * @param level   		Message log level.
	 * @param fmt, args     Log message.
	 */
	template<class... Args>
	void log(std::string_view category, LogLevel level, fmt::format_string<Args...> fmt, Args&&... args);

	/**
	 * @param category      Log category name.
	 * @param level         New log level for this category. Log messages with lower log level will be ignored.
	 */
	void setCategoryLogLevel(std::string_view category, LogLevel level);
}
```

Вы хотите ловить опечатки в названиях категорий, и поэтому в методе `log` вы проверяете, что категория уже зарегистрирована – вы знаете, что у ваших коллег толстые пальцы, и опечатываться они точно будут. Но можно то же самое сделать лучше:

```cpp
class LogCategory {
public:
	LogCategory(std::string_view name, LogLevel level);

	void setLogLevel(LogLevel level);

	// ...
};

class Logger {
public:
	template<class... Args>
	void log(const LogCategory &category, LogLevel level, fmt::format_string<Args...> fmt, Args&&... args);
}
```

При таком API у вас сразу пропадает проблема того, что пользователь может опечататься в названии категории – опечатываться-то теперь негде! Только в назывании переменной типа `LogCategory`, а это поймает компилятор.


# Пример #2: Менеджер CSV файлов

Рассмотрим еще один пример. Предположим, что вы пишете какую-то автоматизацию для машинного обучения, и вам не повезло и все данные хранятся на диске в CSV файлах. Логика приложения такая, что по CSV файлам считаются статистики, которые потом используются в коде – например, для принятия решения об обновлении файла. Вы решаете написать обертку:

```cpp
struct CsvStats {
    DateTime startTime; // First timestamp in CSV table.
    DateTime endTime;   // Last timestamp in CSV table.
    // ...
};

class CsvDb {
public:
    explicit CsvDb(std::string_view path);

    std::string path(std::string_view tableName);

    CsvStats stats(std::string_view tableName);
    void setStats(std::string_view tableName, CsvStats stats);
};
```

В целом очень простой интерфейс – есть возможность получить полный путь до таблицы по имени, и есть getter и setter для статистик. Статистики сохраняются на диске в каком-нибудь `db.ini` и flush'атся после каждого вызова `setStats`. Ожидается, что пользоваться вашей оберткой будут примерно следующим образом:
1. Получат статистику по имени таблицы.
2. Если в таблице не хватает данных – докачают их.
3. Получат путь до файла с таблицей вызвав `path`, подмержат туда скачанные данные.
4. Вызовут `setStats`, чтобы обновить статистики на новые.
5. Используют обновленную таблицу.

Что здесь может пойти не так? Например то, что подсчет статистик – целиком на пользователе, и что подмерживание таблицы и обновление статистик – это не атомарная операция.

Как можно сделать то же самое лучше:

```cpp
struct CsvStats {
    DateTime startTime;
    DateTime endTime;
    // ...
};

class CsvDb {
public:
    explicit CsvDb(std::filesystem::path path);

    CsvTableReader open(std::string_view tableName);
    CsvTableWriter replace(std::string_view tableName);

    CsvStats stats(std::string_view tableName);
};

// Skipping CsvTableReader & CsvTableWriter for brevity.
```

Что изменилось:
* Теперь пользователь нашего интерфейса вообще ничего не знает о файлах.
* Статистики насчитываются и сохраняются внутри `CsvTableWriter`. Пользователю не нужно делать это самому.
* Интерфейс стал лучше отражать суть происходящего – `open` и `replace` это по сути getter и setter для отдельной таблицы, и setter теперь можно реализовать так, чтобы таблица и ее статистика обновлялись атомарно. Предыдущая версия API концентрировалась на getter'ах и setter'ах для статистик


















